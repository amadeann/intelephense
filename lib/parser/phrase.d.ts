import { Token, TokenType } from './lexer';
export declare const enum PhraseType {
    Unknown = 0,
    AdditiveExpression = 1,
    AnonymousClassDeclaration = 2,
    AnonymousClassDeclarationHeader = 3,
    AnonymousFunctionCreationExpression = 4,
    AnonymousFunctionHeader = 5,
    AnonymousFunctionUseClause = 6,
    AnonymousFunctionUseVariable = 7,
    ArgumentExpressionList = 8,
    ArrayCreationExpression = 9,
    ArrayElement = 10,
    ArrayInitialiserList = 11,
    ArrayKey = 12,
    ArrayValue = 13,
    BitwiseExpression = 14,
    BreakStatement = 15,
    ByRefAssignmentExpression = 16,
    CaseStatement = 17,
    CaseStatementList = 18,
    CastExpression = 19,
    CatchClause = 20,
    CatchClauseList = 21,
    CatchNameList = 22,
    ClassBaseClause = 23,
    ClassConstantAccessExpression = 24,
    ClassConstDeclaration = 25,
    ClassConstElement = 26,
    ClassConstElementList = 27,
    ClassDeclaration = 28,
    ClassDeclarationBody = 29,
    ClassDeclarationHeader = 30,
    ClassInterfaceClause = 31,
    ClassMemberDeclarationList = 32,
    ClassModifiers = 33,
    ClassTypeDesignator = 34,
    CloneExpression = 35,
    ClosureUseList = 36,
    CoalesceExpression = 37,
    CompoundAssignmentExpression = 38,
    CompoundStatement = 39,
    TernaryExpression = 40,
    ConstantAccessExpression = 41,
    ConstDeclaration = 42,
    ConstElement = 43,
    ConstElementList = 44,
    ContinueStatement = 45,
    DeclareDirective = 46,
    DeclareStatement = 47,
    DefaultStatement = 48,
    DocBlock = 49,
    DoStatement = 50,
    DoubleQuotedStringLiteral = 51,
    EchoIntrinsic = 52,
    ElseClause = 53,
    ElseIfClause = 54,
    ElseIfClauseList = 55,
    EmptyIntrinsic = 56,
    EncapsulatedExpression = 57,
    EncapsulatedVariable = 58,
    EncapsulatedVariableList = 59,
    EqualityExpression = 60,
    Error = 61,
    ErrorClassMemberDeclaration = 62,
    ErrorClassTypeDesignatorAtom = 63,
    ErrorControlExpression = 64,
    ErrorExpression = 65,
    ErrorScopedAccessExpression = 66,
    ErrorTraitAdaptation = 67,
    ErrorVariable = 68,
    ErrorVariableAtom = 69,
    EvalIntrinsic = 70,
    ExitIntrinsic = 71,
    ExponentiationExpression = 72,
    ExpressionList = 73,
    ExpressionStatement = 74,
    FinallyClause = 75,
    ForControl = 76,
    ForeachCollection = 77,
    ForeachKey = 78,
    ForeachStatement = 79,
    ForeachValue = 80,
    ForEndOfLoop = 81,
    ForExpressionGroup = 82,
    ForInitialiser = 83,
    ForStatement = 84,
    FullyQualifiedName = 85,
    FunctionCallExpression = 86,
    FunctionDeclaration = 87,
    FunctionDeclarationBody = 88,
    FunctionDeclarationHeader = 89,
    FunctionStaticDeclaration = 90,
    FunctionStaticInitialiser = 91,
    GlobalDeclaration = 92,
    GotoStatement = 93,
    HaltCompilerStatement = 94,
    HeredocStringLiteral = 95,
    Identifier = 96,
    IfStatement = 97,
    IncludeExpression = 98,
    IncludeOnceExpression = 99,
    InlineText = 100,
    InstanceOfExpression = 101,
    InstanceofTypeDesignator = 102,
    InterfaceBaseClause = 103,
    InterfaceDeclaration = 104,
    InterfaceDeclarationBody = 105,
    InterfaceDeclarationHeader = 106,
    InterfaceMemberDeclarationList = 107,
    IssetIntrinsic = 108,
    ListIntrinsic = 109,
    LogicalExpression = 110,
    MemberModifierList = 111,
    MemberName = 112,
    MethodCallExpression = 113,
    MethodDeclaration = 114,
    MethodDeclarationBody = 115,
    MethodDeclarationHeader = 116,
    MethodReference = 117,
    MultiplicativeExpression = 118,
    NamedLabelStatement = 119,
    NamespaceAliasingClause = 120,
    NamespaceDefinition = 121,
    NamespaceDefinitionHeader = 122,
    NamespaceDefinitionBody = 123,
    NamespaceName = 124,
    NamespaceUseClause = 125,
    NamespaceUseClauseList = 126,
    NamespaceUseDeclaration = 127,
    NamespaceUseGroupClause = 128,
    NamespaceUseGroupClauseList = 129,
    NullStatement = 130,
    ObjectCreationExpression = 131,
    ParameterDeclaration = 132,
    ParameterDeclarationList = 133,
    PostfixDecrementExpression = 134,
    PostfixIncrementExpression = 135,
    PrefixDecrementExpression = 136,
    PrefixIncrementExpression = 137,
    PrintIntrinsic = 138,
    PropertyAccessExpression = 139,
    PropertyDeclaration = 140,
    PropertyElement = 141,
    PropertyElementList = 142,
    PropertyInitialiser = 143,
    QualifiedName = 144,
    QualifiedNameList = 145,
    RelationalExpression = 146,
    RelativeQualifiedName = 147,
    RelativeScope = 148,
    RequireExpression = 149,
    RequireOnceExpression = 150,
    ReturnStatement = 151,
    ReturnType = 152,
    ScopedCallExpression = 153,
    ScopedMemberName = 154,
    ScopedPropertyAccessExpression = 155,
    ShellCommandExpression = 156,
    ShiftExpression = 157,
    SimpleAssignmentExpression = 158,
    SimpleVariable = 159,
    StatementList = 160,
    StaticVariableDeclaration = 161,
    StaticVariableDeclarationList = 162,
    SubscriptExpression = 163,
    SwitchStatement = 164,
    ThrowStatement = 165,
    TraitAdaptationList = 166,
    TraitAlias = 167,
    TraitDeclaration = 168,
    TraitDeclarationBody = 169,
    TraitDeclarationHeader = 170,
    TraitMemberDeclarationList = 171,
    TraitPrecedence = 172,
    TraitUseClause = 173,
    TraitUseSpecification = 174,
    TryStatement = 175,
    TypeDeclaration = 176,
    UnaryOpExpression = 177,
    UnsetIntrinsic = 178,
    VariableList = 179,
    VariableNameList = 180,
    VariadicUnpacking = 181,
    WhileStatement = 182,
    YieldExpression = 183,
    YieldFromExpression = 184,
}
export interface Phrase {
    phraseType: PhraseType;
    start: number;
    end: number;
    children: (Phrase | Token)[];
}
export interface ParseError extends Phrase {
    unexpected: Token;
    expected?: TokenType;
}
export declare namespace Phrase {
    function create(type: PhraseType, start: number, end: number, children: (Phrase | Token)[]): Phrase;
    function createParseError(start: number, end: number, children: (Phrase | Token)[], unexpected: Token, expected?: TokenType): ParseError;
}
export declare function phraseTypeToString(type: PhraseType): "" | "Unknown" | "AdditiveExpression" | "AnonymousClassDeclaration" | "AnonymousClassDeclarationHeader" | "AnonymousFunctionCreationExpression" | "AnonymousFunctionHeader" | "AnonymousFunctionUseClause" | "AnonymousFunctionUseVariable" | "ArgumentExpressionList" | "ArrayCreationExpression" | "ArrayElement" | "ArrayInitialiserList" | "ArrayKey" | "ArrayValue" | "BitwiseExpression" | "BreakStatement" | "ByRefAssignmentExpression" | "CaseStatement" | "CaseStatementList" | "CastExpression" | "CatchClause" | "CatchClauseList" | "CatchNameList" | "ClassBaseClause" | "ClassConstantAccessExpression" | "ClassConstDeclaration" | "ClassConstElement" | "ClassConstElementList" | "ClassDeclaration" | "ClassDeclarationBody" | "ClassDeclarationHeader" | "ClassInterfaceClause" | "ClassMemberDeclarationList" | "ClassModifiers" | "ClassTypeDesignator" | "CloneExpression" | "ClosureUseList" | "CoalesceExpression" | "CompoundAssignmentExpression" | "CompoundStatement" | "TernaryExpression" | "ConstantAccessExpression" | "ConstDeclaration" | "ConstElement" | "ConstElementList" | "ContinueStatement" | "DeclareDirective" | "DeclareStatement" | "DefaultStatement" | "DoStatement" | "DoubleQuotedStringLiteral" | "EchoIntrinsic" | "ElseClause" | "ElseIfClause" | "ElseIfClauseList" | "EmptyIntrinsic" | "EncapsulatedExpression" | "EncapsulatedVariable" | "EncapsulatedVariableList" | "EqualityExpression" | "Error" | "ErrorClassMemberDeclaration" | "ErrorClassTypeDesignatorAtom" | "ErrorControlExpression" | "ErrorExpression" | "ErrorScopedAccessExpression" | "ErrorTraitAdaptation" | "ErrorVariable" | "ErrorVariableAtom" | "EvalIntrinsic" | "ExitIntrinsic" | "ExponentiationExpression" | "ExpressionList" | "ExpressionStatement" | "FinallyClause" | "ForControl" | "ForeachCollection" | "ForeachKey" | "ForeachStatement" | "ForeachValue" | "ForEndOfLoop" | "ForExpressionGroup" | "ForInitialiser" | "ForStatement" | "FullyQualifiedName" | "FunctionCallExpression" | "FunctionDeclaration" | "FunctionDeclarationHeader" | "FunctionDeclarationBody" | "FunctionStaticDeclaration" | "FunctionStaticInitialiser" | "GlobalDeclaration" | "GotoStatement" | "HaltCompilerStatement" | "HeredocStringLiteral" | "Identifier" | "IfStatement" | "IncludeExpression" | "IncludeOnceExpression" | "InlineText" | "InstanceOfExpression" | "InstanceofTypeDesignator" | "InterfaceBaseClause" | "InterfaceDeclaration" | "InterfaceDeclarationBody" | "InterfaceDeclarationHeader" | "InterfaceMemberDeclarationList" | "IssetIntrinsic" | "ListIntrinsic" | "LogicalExpression" | "MemberModifierList" | "MemberName" | "MethodCallExpression" | "MethodDeclaration" | "MethodDeclarationBody" | "MethodDeclarationHeader" | "MethodReference" | "MultiplicativeExpression" | "NamedLabelStatement" | "NamespaceAliasingClause" | "NamespaceDefinition" | "NamespaceName" | "NamespaceUseClause" | "NamespaceUseClauseList" | "NamespaceUseDeclaration" | "NamespaceUseGroupClause" | "NamespaceUseGroupClauseList" | "NullStatement" | "ObjectCreationExpression" | "ParameterDeclaration" | "ParameterDeclarationList" | "PostfixDecrementExpression" | "PostfixIncrementExpression" | "PrefixDecrementExpression" | "PrefixIncrementExpression" | "PrintIntrinsic" | "PropertyAccessExpression" | "PropertyDeclaration" | "PropertyElement" | "PropertyElementList" | "PropertyInitialiser" | "QualifiedName" | "QualifiedNameList" | "RelationalExpression" | "RelativeQualifiedName" | "RelativeScope" | "RequireExpression" | "RequireOnceExpression" | "ReturnStatement" | "ReturnType" | "ScopedCallExpression" | "ScopedMemberName" | "ScopedPropertyAccessExpression" | "ShellCommandExpression" | "ShiftExpression" | "SimpleAssignmentExpression" | "SimpleVariable" | "StatementList" | "StaticVariableDeclaration" | "StaticVariableDeclarationList" | "SubscriptExpression" | "SwitchStatement" | "ThrowStatement" | "TraitAdaptationList" | "TraitAlias" | "TraitDeclaration" | "TraitDeclarationBody" | "TraitDeclarationHeader" | "TraitMemberDeclarationList" | "TraitPrecedence" | "TraitUseClause" | "TraitUseSpecification" | "TryStatement" | "TypeDeclaration" | "UnaryOpExpression" | "UnsetIntrinsic" | "VariableList" | "VariableNameList" | "VariadicUnpacking" | "WhileStatement" | "YieldExpression" | "YieldFromExpression" | "DocBlock";
